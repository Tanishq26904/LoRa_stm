/*
 * Mesh.c
 *
 *  Created on: Jan 24, 2026
 *      Author: 22142
 */
#include "Mesh.h"
#include "usart.h"
#include "gpio.h"
#include "LoRa.h"

uint32_t lastActivityTime = 0;
uint32_t watchdogTimeout = 30000;
uint8_t radioErrorCount = 0;
uint32_t lastResetTime = 0;
uint32_t lcg_seed = 0;

float dp = 1;
float t_in = 2;
float t_out = 3;
float p_header = 4;
float pm = 5;
uint8_t cleaning = 0;

#define DUP_CACHE_SIZE        16
typedef struct {
  uint8_t src;
  uint16_t msg_id;
} SeenPacket;
SeenPacket seenPackets[DUP_CACHE_SIZE];
uint8_t seenIndex = 0;

void Mesh_reset_watchdog(void) {
    lastActivityTime = HAL_GetTick();
}

void Mesh_check_watchdog(void) {
    if (HAL_GetTick() - lastActivityTime > watchdogTimeout) {
        for (int i = 0; i < 5; i++) {
            HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_2);
            HAL_Delay(100);
        }
        NVIC_SystemReset();
    }
}

void Mesh_hard_reset_radio(void) {
    // Hard reset the radio
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    // Ensure NSS is high
    HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);
    HAL_Delay(10);

    radioErrorCount = 0;
    lastResetTime = HAL_GetTick();
}

uint8_t Mesh_isDuplicate(uint8_t src, uint16_t msg_id)
{
  for (uint8_t i = 0; i < DUP_CACHE_SIZE; i++)
  {
    if (seenPackets[i].src == src &&
        seenPackets[i].msg_id == msg_id)
    {
      return 1;
    }
  }
  return 0;
}

void Mesh_rememberPacket(uint8_t src, uint16_t msg_id)
{
  seenPackets[seenIndex].src = src;
  seenPackets[seenIndex].msg_id = msg_id;

  seenIndex++;
  if (seenIndex >= DUP_CACHE_SIZE)
    seenIndex = 0;
}

uint32_t Mesh_lcg_rand(void)
{
    lcg_seed = (1103515245 * lcg_seed + 12345);
    return (lcg_seed >> 16) & 0x7FFF;
}

float Mesh_rand_range(float min, float max)
{
    return min + ((float)Mesh_lcg_rand() / 32767.0f) * (max - min);
}

uint8_t Mesh_check_radio_status(LoRa *radio)
{
    uint8_t version = LoRa_read(radio, RegVersion);
    if (version != 0x12) {
        return 0;
    }

    uint8_t op_mode = LoRa_read(radio, RegOpMode);
    uint8_t mode = op_mode & 0x07;

    if (mode != 0x01 && mode != 0x03 && mode != 0x05) {
        return 0;
    }
    return 1;
}

void Mesh_check_radio_health(LoRa *radio) {
    static uint32_t lastCheck = 0;

    if (HAL_GetTick() - lastCheck > 5000) {
        uint8_t version = LoRa_read(radio, RegVersion);
        if (version != 0x12) {
            // Only reset if we've had multiple errors
            if (radioErrorCount++ > 3) {
                Mesh_hard_reset_radio();
                HAL_Delay(100);
                LoRa_init(radio);
                LoRa_setSyncWord(radio, 0x34);
                LoRa_setSpreadingFactor(radio, 7);
                LoRa_enableCRC(radio, 1);
                LoRa_startReceiving(radio);
            }
        } else {
            radioErrorCount = 0; // Reset error count on success
        }
        lastCheck = HAL_GetTick();
    }
}

uint8_t Mesh_wait_for_tx_complete(LoRa *radio) {
    uint32_t start = HAL_GetTick();
    while ((HAL_GetTick() - start) < 1000) { // 1 second timeout
        uint8_t irq_flags = LoRa_read(radio, RegIrqFlags);
        if (irq_flags & 0x08) { // TxDone flag
            LoRa_write(radio, RegIrqFlags, 0xFF); // Clear all IRQ flags
            return 1;
        }
        HAL_Delay(1);
    }
    return 0;
}

/**************************************************************************************************************/

										//  LoRa ***IMP*** Functions //

/**************************************************************************************************************/
void handle_req_data(uint8_t src_id, uint16_t msg_id)
{
    // Generate random sensor values
    dp       = Mesh_rand_range(1200.0f, 1300.0f);
    t_in     = Mesh_rand_range(10.0f, 20.0f);
    t_out    = Mesh_rand_range(170.0f, 190.0f);
    p_header = Mesh_rand_range(55.0f, 65.0f);
    pm       = Mesh_rand_range(10.0f, 15.0f);
    cleaning = (Mesh_lcg_rand() % 2) ? 1 : 0;

    // Format sensor data
    snprintf(payloadBuf, sizeof(payloadBuf),
             "%.1f,%.1f,%.1f,%.1f,%.1f,%d",
             dp, t_in, t_out, p_header, pm, cleaning);

    // Send sensor data with MeshHeader - using the SAME msg_id as the request
    LoRa_Transmit(PKT_SENSOR_DATA, src_id, nodeId, payloadBuf, msg_id);
}

void Mesh_handle_req_data(
    uint8_t src_id,
    uint16_t msg_id,
    uint8_t self_id,
    char *payloadBuf,
    size_t payloadBufLen
)
{
    float dp       = Mesh_rand_range(1200.0f, 1300.0f);
    float t_in     = Mesh_rand_range(10.0f, 20.0f);
    float t_out    = Mesh_rand_range(170.0f, 190.0f);
    float p_header = Mesh_rand_range(55.0f, 65.0f);
    float pm       = Mesh_rand_range(10.0f, 15.0f);
    uint8_t cleaning = (Mesh_lcg_rand() % 2) ? 1 : 0;

    snprintf(payloadBuf, payloadBufLen,
             "%.1f,%.1f,%.1f,%.1f,%.1f,%d",
             dp, t_in, t_out, p_header, pm, cleaning);

    LoRa_Transmit(PKT_SENSOR_DATA, src_id, self_id, payloadBuf, msg_id);
}


