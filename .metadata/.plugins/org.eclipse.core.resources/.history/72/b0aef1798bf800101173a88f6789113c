/* USER CODE BEGIN 4 */
#ifdef USE_UART
void printu(const char *msg)
{
  HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 200);
}

void print_dbg(const char *format, ...)
{
    va_list args;
    va_start(args, format);
    int len = vsnprintf(dbg_buf, DBG_BUF_SIZE, format, args);
    va_end(args);

    if (len > 0) {
        printu(dbg_buf);
    }
}

void print_node_id(uint8_t nodeId)
{
    char buf[4];   // only 4 bytes on stack
    buf[0] = '0' + (nodeId / 10);
    buf[1] = '0' + (nodeId % 10);
    buf[2] = '\r';
    buf[3] = '\n';

    printu("Node ID: ");
    printu(buf);
}

void print_reset_reason(void)
{
    uint32_t flags = RCC->CSR;
    if(flags & RCC_CSR_LPWRRSTF) {
        printu("Reset Reason: Low Power (Brown-out)\r\n");
    } else if(flags & RCC_CSR_WWDGRSTF) {
        printu("Reset Reason: Window Watchdog\r\n");
    } else if(flags & RCC_CSR_IWDGRSTF) {
        printu("Reset Reason: Independent Watchdog\r\n");
    } else if(flags & RCC_CSR_SFTRSTF) {
        printu("Reset Reason: Software Reset\r\n");
    } else if(flags & RCC_CSR_PORRSTF) {
        printu("Reset Reason: Power-on Reset\r\n");
    } else if(flags & RCC_CSR_PINRSTF) {
        printu("Reset Reason: External Pin Reset\r\n");
    } else {
        printu("Reset Reason: Unknown\r\n");
    }
    RCC->CSR |= RCC_CSR_RMVF;
}
#endif

void STM32_GetUID(uint32_t uid_out[3])
{
    uid_out[0] = *(uint32_t*)0x1FFFF7E8;
    uid_out[1] = *(uint32_t*)0x1FFFF7EC;
    uid_out[2] = *(uint32_t*)0x1FFFF7F0;
}

void reset_watchdog(void) {
    lastActivityTime = HAL_GetTick();
}

void check_watchdog(void) {
    if (HAL_GetTick() - lastActivityTime > watchdogTimeout) {
#ifdef USE_UART
        printu("üîÑ Watchdog timeout - Resetting system\r\n");
#endif
        for (int i = 0; i < 5; i++) {
            HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_2);
            HAL_Delay(100);
        }
        NVIC_SystemReset();
    }
}

void hard_reset_radio(void) {
#ifdef USE_UART
    printu("Resetting radio...\r\n");
#endif
    // Hard reset the radio
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(100);

    // Ensure NSS is high
    HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);
    HAL_Delay(10);

    radioErrorCount = 0;
    lastResetTime = HAL_GetTick();
}

void check_radio_health(void) {
    static uint32_t lastCheck = 0;

    if (HAL_GetTick() - lastCheck > 5000) {
        uint8_t version = LoRa_read(&myLoRa, RegVersion);
        if (version != 0x12) {
#ifdef USE_UART
            print_dbg("‚ö†Ô∏è Radio version mismatch: 0x%02X\r\n", version);
#endif
            // Only reset if we've had multiple errors
            if (radioErrorCount++ > 3) {
                hard_reset_radio();
                HAL_Delay(100);
                LoRa_init(&myLoRa);
                LoRa_setSyncWord(&myLoRa, 0x34);
                LoRa_setSpreadingFactor(&myLoRa, 7);
                LoRa_enableCRC(&myLoRa, 1);
                LoRa_startReceiving(&myLoRa);
            }
        } else {
            radioErrorCount = 0; // Reset error count on success
        }
        lastCheck = HAL_GetTick();
    }
}

uint8_t check_radio_status(void) {
    // Check if radio is responding
    uint8_t version = LoRa_read(&myLoRa, RegVersion);
    if (version != 0x12) {
#ifdef USE_UART
        print_dbg("Radio version wrong: 0x%02X\r\n", version);
#endif
        return 0;
    }

    // Check if in a valid mode
    uint8_t op_mode = LoRa_read(&myLoRa, RegOpMode);
    uint8_t mode = op_mode & 0x07;

    // Mode should be 0x01 (STDBY), 0x03 (TX), or 0x05 (RX continuous)
    if (mode != 0x01 && mode != 0x03 && mode != 0x05) {
#ifdef USE_UART
        print_dbg("Radio in wrong mode: 0x%02X\r\n", mode);
#endif
        return 0;
    }

    return 1;
}

uint8_t wait_for_tx_complete(void) {
    uint32_t start = HAL_GetTick();
    while ((HAL_GetTick() - start) < 5000) { // Increased to 5 second timeout
        uint8_t irq_flags = LoRa_read(&myLoRa, RegIrqFlags);

        // Check for TxDone flag (bit 3) OR Timeout flag (bit 7)
        if (irq_flags & 0x08) { // TxDone flag
            LoRa_write(&myLoRa, RegIrqFlags, 0xFF); // Clear all IRQ flags
#ifdef USE_UART
            printu("‚úÖ TxDone detected\r\n");
#endif
            return 1;
        }

        // Also check for timeout
        if (irq_flags & 0x80) { // Timeout flag
#ifdef USE_UART
            printu("‚ö†Ô∏è Tx timeout flag set\r\n");
#endif
            LoRa_write(&myLoRa, RegIrqFlags, 0xFF); // Clear all IRQ flags
            return 0;
        }

        // Check if radio is still in TX mode
        uint8_t op_mode = LoRa_read(&myLoRa, RegOpMode);
        uint8_t mode = op_mode & 0x07;

        if (mode != 0x03) { // Not in TX mode anymore
            // Radio left TX mode without setting TxDone flag
#ifdef USE_UART
            print_dbg("‚ö†Ô∏è Radio left TX mode (mode=0x%02X)\r\n", mode);
#endif
            return 0;
        }

        HAL_Delay(10); // Smaller delay for more responsive checking
    }
#ifdef USE_UART
    printu("‚ùå TX timeout after 5 seconds\r\n");
#endif
    return 0;
}

/* ---------------- Registration with MeshHeader -------------- */
void req_Registration(void)
{
    static uint32_t lastRegistrationAttempt = 0;

    // Don't try too often
    if (HAL_GetTick() - lastRegistrationAttempt < 10000) { // Increased to 10 seconds
        return;
    }

    lastRegistrationAttempt = HAL_GetTick();

    // Create UID string payload
    snprintf(payloadBuf, sizeof(payloadBuf),
             "%08lX-%08lX-%08lX",
             uid[0], uid[1], uid[2]);

#ifdef USE_UART
    printu("üì§ Sending registration request...\r\n");
#endif

    // Send registration request with MeshHeader
    uint16_t msg_id = lcg_rand() & 0xFFFF;
    uint8_t result = LoRa_Transmit(PKT_REQ_ADDRESS, 0xFF, 0, payloadBuf, msg_id);

    if (result) {
#ifdef USE_UART
        printu("‚úÖ Registration request sent successfully\r\n");
#endif
        // Wait for ACK with MeshHeader
        uint8_t ack = wait_for_ack(5000); // Increased timeout to 5 seconds
        if (ack != 0xFF) {
            return;
        }
    }
    else
    {
#ifdef USE_UART
        printu("‚ùå Registration request failed\r\n");
#endif
    }
}

/* ---------------- Wait for ACK with MeshHeader ---------------- */
uint8_t wait_for_ack(uint16_t timeout_ms)
{
#ifdef USE_UART
    print_dbg("‚åõ Waiting for ACK (timeout=%dms)...\r\n", timeout_ms);
#endif
    uint32_t start = HAL_GetTick();

    while ((HAL_GetTick() - start) < timeout_ms)
    {
        uint8_t len = LoRa_receive(&myLoRa, rxBuf, sizeof(rxBuf) - 1);
        if (len > 0)
        {
            reset_watchdog(); // Reset watchdog on reception

            // Check if we have enough bytes for a header
            if (len < sizeof(MeshHeader)) {
                continue;
            }

            MeshHeader *hdr = (MeshHeader *)rxBuf;

            // Check version
            if (hdr->version != MESH_VERSION) {
#ifdef USE_UART
                print_dbg("  Wrong version: %d\r\n", hdr->version);
#endif
                continue;
            }

            // Check packet type
            if (hdr->type != PKT_ACK_ADDRESS) {
#ifdef USE_UART
                print_dbg("  Not ACK_ADDRESS: %d\r\n", hdr->type);
#endif
                continue;  // Not an ACK_ADDRESS packet
            }

            // Check duplicate
            if (isDuplicate(hdr->src, hdr->msg_id)) {
#ifdef USE_UART
                print_dbg("  Duplicate packet\r\n");
#endif
                continue;
            }

            // Remember this packet
            rememberPacket(hdr->src, hdr->msg_id);

            // Extract payload (starts after header)
            uint8_t payloadStart = sizeof(MeshHeader);
            uint8_t payloadLen = hdr->payload_len;

            if (payloadLen > (len - payloadStart)) {
                payloadLen = len - payloadStart;
            }

            if (payloadLen > 0) {
                memcpy(payloadBuf, &rxBuf[payloadStart], payloadLen);
                payloadBuf[payloadLen] = '\0';
            } else {
                payloadBuf[0] = '\0';
            }

#ifdef USE_UART
            printu("üì• Received ACK_ADDRESS packet\r\n");
            print_dbg("  From: %d, MsgID: %d, Len: %d\r\n", hdr->src, hdr->msg_id, payloadLen);
            if (payloadLen > 0) {
                print_dbg("  Payload: %s\r\n", payloadBuf);
            }
#endif

            // Parse payload: format is "UID|nodeId"
            uint32_t r_uid0 = 0, r_uid1 = 0, r_uid2 = 0;
            unsigned int assignedId = 0;

            int parsed = sscanf(payloadBuf,
                                "%08lX-%08lX-%08lX|%u",
                                &r_uid0, &r_uid1, &r_uid2,
                                &assignedId);

            if (parsed == 4)
            {
                if (r_uid0 == uid[0] && r_uid1 == uid[1] && r_uid2 == uid[2])
                {
                    nodeId = (int)assignedId;
#ifdef USE_UART
                    print_dbg("‚úÖ Node ID assigned: %02d\r\n", nodeId);
                    printu("‚ö†Ô∏è Node ID stored in RAM only (volatile)\r\n");
#endif
                    // Send ACK back to confirm
                    HAL_Delay(100); // Small delay before sending ACK
                    LoRa_Transmit(PKT_ACK, Master, nodeId, "", hdr->msg_id);

                    return (uint8_t)nodeId;
                } else {
#ifdef USE_UART
                    printu("‚ùå UID mismatch in ACK\r\n");
#endif
                }
            } else {
#ifdef USE_UART
                print_dbg("‚ùå ACK parse failed (parsed=%d)\r\n", parsed);
#endif
            }
        }
        HAL_Delay(10); // Small delay to prevent busy waiting
    }

#ifdef USE_UART
    printu("‚è±Ô∏è Timeout waiting for ACK\r\n");
#endif
    return 0xFF;
}

/* -------------- Transmit with MeshHeader - Improved Version ------------- */
uint8_t LoRa_Transmit(uint8_t type, uint8_t dst, uint8_t src, const char *payload, uint16_t msg_id)
{
    MeshHeader hdr;
    uint8_t payload_len = payload ? strlen(payload) : 0;
    uint16_t total_len = sizeof(MeshHeader) + payload_len;

    // Validate length
    if (total_len > sizeof(txBuf)) {
#ifdef USE_UART
        printu("‚ùå TX error: Packet too large\r\n");
#endif
        return 0;
    }

    // Build header
    hdr.version = MESH_VERSION;
    hdr.type = type;
    hdr.src = src;
    hdr.dest = dst;
    hdr.ttl = 5;
    hdr.flags = 0;
    hdr.msg_id = msg_id;
    hdr.payload_len = payload_len;

    // Build complete packet
    memcpy(txBuf, &hdr, sizeof(MeshHeader));
    if (payload_len > 0) {
        memcpy(txBuf + sizeof(MeshHeader), payload, payload_len);
    }

    // Check radio status before attempting transmission
    if (!check_radio_status()) {
#ifdef USE_UART
        printu("‚ö†Ô∏è Radio not ready, resetting...\r\n");
#endif
        hard_reset_radio();
        HAL_Delay(100);
        LoRa_init(&myLoRa);
        LoRa_setSyncWord(&myLoRa, 0x34);
        LoRa_setSpreadingFactor(&myLoRa, 7);
        LoRa_enableCRC(&myLoRa, 1);
        LoRa_startReceiving(&myLoRa);
        HAL_Delay(100);

        // Check again
        if (!check_radio_status()) {
#ifdef USE_UART
            printu("‚ùå Radio still not ready after reset\r\n");
#endif
            return 0;
        }
    }

    // Ensure radio is in standby mode for TX
    LoRa_gotoMode(&myLoRa, STNBY_MODE);
    HAL_Delay(20); // Reduced delay

    // Clear any pending IRQ flags
    LoRa_write(&myLoRa, RegIrqFlags, 0xFF);

    // Print debug info
#ifdef USE_UART
    print_dbg("üì§ TX: type=%d, dst=%d, src=%d, msg_id=%d, len=%d\r\n",
              type, dst, src, msg_id, total_len);

    if (payload_len > 0 && payload_len < 50) {
        print_dbg("    Payload: %s\r\n", payload);
    }
#endif

    // Transmit with timeout - using library's transmit function
    uint16_t tx_result = LoRa_transmit(&myLoRa, txBuf, total_len, 5000); // Increased timeout to 5 seconds

    if (tx_result == 1) {
        // Wait for TxDone with improved checking
        if (wait_for_tx_complete()) {
#ifdef USE_UART
            printu("‚úÖ TX successful\r\n");
#endif
            radioErrorCount = 0; // Reset error count on success

            // Return to RX mode
            LoRa_startReceiving(&myLoRa);
            HAL_Delay(20); // Small delay before returning
            return 1;
        } else {
#ifdef USE_UART
            printu("‚ùå TX did not complete (no TxDone flag)\r\n");
#endif
            // Force radio back to RX mode
            LoRa_startReceiving(&myLoRa);
            return 0;
        }
    }
    else if (tx_result == 0) {
#ifdef USE_UART
        printu("‚ùå LoRa_transmit returned failure\r\n");
#endif
    }
    else {
#ifdef USE_UART
        print_dbg("‚ö†Ô∏è LoRa_transmit returned: %d\r\n", tx_result);
#endif
    }

    // If we get here, transmission failed
    radioErrorCount++;

    // If we have multiple consecutive errors, hard reset
    if (radioErrorCount > 3) {
#ifdef USE_UART
        print_dbg("‚ö†Ô∏è Multiple TX failures (%d), resetting radio...\r\n", radioErrorCount);
#endif
        hard_reset_radio();
        HAL_Delay(100);
        LoRa_init(&myLoRa);
        LoRa_setSyncWord(&myLoRa, 0x34);
        LoRa_setSpreadingFactor(&myLoRa, 7);
        LoRa_enableCRC(&myLoRa, 1);
        LoRa_startReceiving(&myLoRa);
        radioErrorCount = 0;
    } else {
        // Soft recovery: restart RX mode
        LoRa_startReceiving(&myLoRa);
    }

    return 0;
}
