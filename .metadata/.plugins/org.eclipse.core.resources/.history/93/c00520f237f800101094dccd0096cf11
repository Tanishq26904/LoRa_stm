/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body (clean RX model)
  ******************************************************************************
  */
#include "main.h"
#include "spi.h"
#include "usart.h"
#include "gpio.h"

#include <string.h>
#include <stdio.h>
#include "LoRa.h"
#include <stdint.h>
#include <stdlib.h>
#include "stm32f1xx.h"
#include "stm32f1xx_hal_flash.h"
#include "stm32f1xx_hal_flash_ex.h"

/* ===================== DEFINES ===================== */
#define FLASH_STORAGE_START  0x0800FC00
#define FLASH_MAGIC_NUMBER   0x55AA1234

#define MESH_VERSION          0x01
#define PKT_REQ_ADDRESS       0x01
#define PKT_ACK_ADDRESS       0x02
#define PKT_REQ_DATA          0x03
#define PKT_SENSOR_DATA       0x04
#define PKT_ACK               0x05

#define DUP_CACHE_SIZE        16

/* ===================== TYPES ===================== */
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint32_t counter;
    uint32_t device_id;
    uint32_t checksum;
} stored_data_t;

typedef struct __attribute__((packed)) {
    uint8_t  version;
    uint8_t  type;
    uint8_t  src;
    uint8_t  dest;
    uint8_t  ttl;
    uint8_t  flags;
    uint16_t msg_id;
    uint8_t  payload_len;
} MeshHeader;

typedef struct {
    uint8_t  src;
    uint16_t msg_id;
} SeenPacket;

/* ===================== GLOBALS ===================== */
LoRa myLoRa;
uint16_t LoRa_status;

uint32_t uid[3];
uint8_t  Master = 1;
uint8_t  nodeId = 0;

float dp, t_in, t_out, p_header, pm;
uint8_t cleaning;

static uint32_t lcg_seed = 0;

uint8_t rxBuf[256];
uint8_t txBuf[256];
char    payloadBuf[128];

SeenPacket seenPackets[DUP_CACHE_SIZE];
uint8_t seenIndex = 0;

/* ===================== PROTOTYPES ===================== */
void SystemClock_Config(void);
void STM32_GetUID(uint32_t uid[3]);
uint8_t isDuplicate(uint8_t src, uint16_t msg_id);
void rememberPacket(uint8_t src, uint16_t msg_id);

uint8_t LoRa_Transmit(uint8_t type, uint8_t dst, uint8_t src,
                      const char *payload, uint16_t msg_id);

void LoRa_StartPollingnode(void);
void handle_req_data(uint8_t src_id, uint16_t msg_id);

/* ===================== MAIN ===================== */
int main(void)
{
    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();
    MX_SPI1_Init();
    MX_USART1_UART_Init();

    lcg_seed = HAL_GetTick();

    /* SX127x reset */
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(10);
    HAL_GPIO_WritePin(RESET_GPIO_Port, RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(10);

    myLoRa = newLoRa();
    myLoRa.CS_port = NSS_GPIO_Port;
    myLoRa.CS_pin  = NSS_Pin;
    myLoRa.reset_port = RESET_GPIO_Port;
    myLoRa.reset_pin  = RESET_Pin;
    myLoRa.DIO0_port  = DIO0_GPIO_Port;
    myLoRa.DIO0_pin   = DIO0_Pin;
    myLoRa.hSPIx      = &hspi1;

    LoRa_status = LoRa_init(&myLoRa);
    LoRa_setSyncWord(&myLoRa, 0x34);
    LoRa_enableCRC(&myLoRa, 1);

    /* FIFO base reset */
    LoRa_write(&myLoRa, RegFiFoRxBaseAddr, 0x00);
    LoRa_write(&myLoRa, RegFiFoTxBaseAddr, 0x80);

    LoRa_startReceiving(&myLoRa);

    STM32_GetUID(uid);

    while (1)
    {
        if (nodeId > 0)
            LoRa_StartPollingnode();
    }
}

/* ===================== RADIO TX ===================== */
uint8_t LoRa_Transmit(uint8_t type, uint8_t dst, uint8_t src,
                      const char *payload, uint16_t msg_id)
{
    MeshHeader hdr;
    uint8_t payload_len = payload ? strlen(payload) : 0;
    uint16_t total_len = sizeof(MeshHeader) + payload_len;

    hdr.version = MESH_VERSION;
    hdr.type = type;
    hdr.src = src;
    hdr.dest = dst;
    hdr.ttl = 5;
    hdr.flags = 0;
    hdr.msg_id = msg_id;
    hdr.payload_len = payload_len;

    LoRa_gotoMode(&myLoRa, STNBY_MODE);
    HAL_Delay(2);

    memcpy(txBuf, &hdr, sizeof(MeshHeader));
    if (payload_len)
        memcpy(txBuf + sizeof(MeshHeader), payload, payload_len);

    uint8_t ok = LoRa_transmit(&myLoRa, txBuf, total_len, 2000);

    /* ðŸ”¥ CRITICAL: reset FIFO after TX */
    LoRa_write(&myLoRa, RegFiFoRxBaseAddr, 0x00);
    LoRa_write(&myLoRa, RegFiFoTxBaseAddr, 0x80);

    LoRa_startReceiving(&myLoRa);
    return ok;
}

/* ===================== RX POLLING ===================== */
void LoRa_StartPollingnode(void)
{
    uint8_t len = LoRa_receive(&myLoRa, rxBuf, sizeof(rxBuf) - 1);

    if (len == 0 || len < sizeof(MeshHeader))
        return;

    rxBuf[len] = '\0';  // ðŸ”¥ REQUIRED

    MeshHeader *hdr = (MeshHeader *)rxBuf;

    if (hdr->version != MESH_VERSION)
        return;

    if (hdr->dest != nodeId && hdr->dest != 0xFF)
        return;

    if (isDuplicate(hdr->src, hdr->msg_id))
        return;

    rememberPacket(hdr->src, hdr->msg_id);

    if (hdr->type == PKT_REQ_DATA)
    {
        /* ACK first */
        LoRa_Transmit(PKT_ACK, hdr->src, nodeId, "", hdr->msg_id);
        HAL_Delay(30);   // ðŸ”¥ reduced from 500ms

        handle_req_data(hdr->src, rand());
    }
}

/* ===================== SENSOR RESPONSE ===================== */
void handle_req_data(uint8_t src_id, uint16_t msg_id)
{
    dp       = 1200.0f + (rand() % 100);
    t_in     = 10.0f + (rand() % 10);
    t_out    = 170.0f + (rand() % 20);
    p_header = 55.0f + (rand() % 10);
    pm       = 10.0f + (rand() % 5);
    cleaning = rand() & 1;

    snprintf(payloadBuf, sizeof(payloadBuf),
             "%.1f,%.1f,%.1f,%.1f,%.1f,%d",
             dp, t_in, t_out, p_header, pm, cleaning);

    LoRa_Transmit(PKT_SENSOR_DATA, src_id, nodeId,
                  payloadBuf, msg_id);
}

/* ===================== UTIL ===================== */
uint8_t isDuplicate(uint8_t src, uint16_t msg_id)
{
    for (uint8_t i = 0; i < DUP_CACHE_SIZE; i++)
        if (seenPackets[i].src == src &&
            seenPackets[i].msg_id == msg_id)
            return 1;
    return 0;
}

void rememberPacket(uint8_t src, uint16_t msg_id)
{
    seenPackets[seenIndex].src = src;
    seenPackets[seenIndex].msg_id = msg_id;
    seenIndex = (seenIndex + 1) % DUP_CACHE_SIZE;
}

void STM32_GetUID(uint32_t uid_out[3])
{
    uid_out[0] = *(uint32_t*)0x1FFFF7E8;
    uid_out[1] = *(uint32_t*)0x1FFFF7EC;
    uid_out[2] = *(uint32_t*)0x1FFFF7F0;
}

void Error_Handler(void)
{
    __disable_irq();
    while (1);
}
